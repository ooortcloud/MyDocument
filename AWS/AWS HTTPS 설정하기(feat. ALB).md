# AWS HTTPS 설정 메뉴얼

# 1. 도메인 별칭 등록 및 ACM 인증

[내 도메인 한국](https://xn--220b31d95hq8o.xn--3e0b707e/page/domain_conf_view.php?id=1517724&order=1&page=1) 사이트를 통해 도메인을 발급받았다는 전제 하에 진행하겠다.

## 인증서 요청 (도메인 SSL 인증)

1. 아래 링크에서 `인증서 요청` 을 클릭한다.
[ACM 사이트](https://us-east-2.console.aws.amazon.com/acm/home?region=us-east-2#/certificates/list)
2. `퍼블릭 인증서 요청` 을 선택하고 다음을 누른다.
3. 도메인 이름에는 자신이 발급받은 도메인 이름을 넣어준다.
    1. www.example.com
    2. ~~*.example.com~~ (Route 53에서 레코드 생성 시 적용되지 않는 문제 확인)
4. 검증 방법은 `DNS 검증`을 선택한다. DNS 제공 업체의 소유주만이 이 도메인을 검증할 수 있기 때문에 이것만 선택 가능하다.
5. 키 알고리즘은 가장 무난한 거 선택.
6. 태그는 자유
7. 요청을 누르면 인증서가 제공되며, 이 인증서는 “검증 대기 중”에 들어가게 된다.

## DNS 검증하기

이 인증서를 CNAME을 사용하여 검증을 받을 것이다.

### CNAME 레코드

`CNAME 레코드` 는 별칭을 지정하는 레코드이며, 어떤 도메인을 다른 도메인으로 `리다이렉트`하는 데 사용된다. 예를 들어, "www.example.com”에 대한 CNAME 레코드를 “abcdef.example.com”으로 설정하면, “www.example.com”에 대한 요청은 전부 “abcdef.example.com”으로 리다이렉트 된다.

이 키-값은 유일한 값이기 때문에, CNAME 도메인 레코드가 사용자에게 소유권이 있다는 것을 증명한다.

### DNS 검증 진행 과정

1. ACM에서 발급받은 인증서의 세부 사항에 들어가서, 도메인의 CNAME 값과 이름을 확인한다.
2. [내 도메인 한국](https://xn--220b31d95hq8o.xn--3e0b707e/page/domain_conf_view.php?id=1517724&order=1&page=1) 사이트에서 `도메인 관리` 항목에 들어간다.
3. DNS 고급 설정에서 `별칭(CNAME)` 항목에 방금 확인한 CNAME 이름과 값을 넣어줄 것이다.
    1. `CNAME 이름`을 ~.example.com 형태의 칸 앞에 넣어준다. 이때 전체 키값이 아닌, 키값의 인증 해시 부분만 넣어주면 된다. **주의: “www”는 인증 해시 부분에 포함되므로 빼먹으면 안된다. (CNAME 이름에 포함되어 있는 경우에 한함.)**
    2. `CNAME 값` 을 바로 옆 칸에 넣어준다. 이 때 CNAME 값 맨 끝에 ‘.’을 빼줘야 에러없이 동작한다.
4. 수정이 끝나면 5분 정도 기다린다.
5. ACM에서 인증서의 상태가 “발급됨”인지 확인한다.

[참고링크](https://hyeon9mak.github.io/change-cloudfront-domain-name/#-%EB%B0%98%EC%98%81-%ED%99%95%EC%9D%B8)

# 2. SSL 인증서 발급

[내 도메인 한국](https://xn--220b31d95hq8o.xn--3e0b707e/page/domain_conf_view.php?id=1517724&order=1&page=1) 사이트에서는 네임서버를 설정할 수 없다. 그래도 CNAME으로 진행이 가능하므로 걱정하지 말라.

**주의: Route 53에서는 “www”가 없는 루트 도메인에 대해서 CNAME 레코드 등록을 허용하지 않는다.**

### Route 53

AWS의 관리형 DNS 서비스이다. DNS는 도메인 이름과 IP 주소 간의 매핑을 관리한다.

route 53은 아래와 같은 기능들을 제공한다.

- 도메인 등록 및 관리
- DNS 라우팅 설정: 트래픽 제어 가능
- 가용성 및 내결함성: AWS의 여러 서비스들과 통합됨
- 호스트 영역 생성: DNS 서비스를 위해 도메인 이름을 등록한 후, 도메인 이름에 대한 DNS 레코드를 설정하는 것이다. DNS 레코드에는 도메인 이름을 IP 주소나 다른 리소스와 연결하는 정보들이 포함된다. 이를 통해 도메인을 관리하고 리소스와의 연결을 설정하여, 원하는 방식으로 DNS 라우팅을 구성할 수 있다.

## 호스팅 영역 생성

1. Route 53에서 `호스팅 영역 생성` 을 누른다.
2. 도메인 이름에 자신이 발급받은 도메인을 입력한다. (www.example.com)
3. 그리고 호스팅 영역 생성을 누른다.
4. 호스팅 영역 세부 정보에서 `레코드 생성` 을 누른다.
5. 라우팅 정책은 알아서. (단순 라우팅으로 선택했음)
6. 레코드 구성에서 `단순 레코드 정의` 를 누른다.
    1. 레코드 이름: 앞에 ACM에서 발급받은 도메인의 `CNAME 이름`을 입력한다. (인증해시 부분만)
    2. 레코드 유형: `CNAME`으로 설정.
    3. 값/트래핑 라우팅 대상: “레코드 유형에 따른 IP 주소 또는 다른 값”을 선택한 뒤, 아래 빈 블록에 `CNAME 값`을 넣는다.
    4. TLL은 자유
7. 그리고 레코드 생성을 누른다.

## Route 53에서 레코드 생성

다시 ACM으로 돌아와서, 이전에 발급했던 인증서의 세부 설정으로 들어온다. 그리고 `Route 53에서 레코드 생성` 버튼을 클릭한다. 아까 만들었던 레코드와 함께 그대로 레코드 생성을 누른다.

그리고 잠시 기다리다가, 도메인의 상태가 “성공”이 되었는지 확인한다.

참고: 우리가 방금 사용한 CNAME은 AWS에서 생성한 인증용 링크이다. 이거를 서버 URL로 활용할 수는 없다.

# 3. 어플리케이션 로드 벨런서(ALB) 설정

새로 발급받은 인증서가 사용 중이 아니고, 갱신 자격이 “부적격”인 상태이면 오케이. 이 인증서는 사용 가능한 인증서인 것이다. 이제 로드 벨런서를 추가해주자.

## 어플리케이션 로드 벨런서 생성하기

1. 로드 벨런서 기능은 인스턴스 란에 있다. 인스턴스 서비스로 이동하자.
2. `Create load balancer`를 누른다.
3. 로드 벨런서 타입은 `Application Load Balancer(ALB)` 로 한다. 그림으로도 친절히 https 우회 설정이라고 설명되어 있다. 
4. `Network Mapping` 부분에서 인스턴스의 가용 영역에 해당하는 mapping을 포함시켜 설정한다.
5. `Security Groups` 부분에서 ALB용 보안 규칙을 추가한다. 80번 포트와 443번 포트를 반드시 ALB에 접근할 수 있도록 해야 한다. 그 외의 포트 설정은 필요없다.
    1. TCP:80  0.0.0.0/0
    2. TCP:443  0.0.0.0/0
6. `Listeners and Routing` 부분에서 Listener에 `HTTPS:443`을 추가한다.
    1. 그리고 `target group`을 생성해줘야 하는데, web(백엔드 서버 포트)와 was(프론트 서버 포트) 따로 target group 만들어서 선택해준다.
        1. target group에서는 http로 소통하게 설정한다. (서버와 서버끼리는 굳이 https 통신할 필요 없음.)
        2. web-target: HTTP:8080으로 설정. 그리고 registered target은 기존 인스턴스 서버의 8080 포트를 지정한다.
        3. was-target: HTTP:3000으로 설정. 그리고 registered target은 기존 인스턴스 서버의 3000 포트를 지정한다.
    2. HTTP:80 Listener에는 web-target을, 그리고 HTTPS:443 Listener에는 was-target을 action 대상으로 설정한다. (클라이언트 요청에 대한 ALB의 행동 방침을 정하는 것.)
7. `Secure listener settings` 부분에서 Default SSL/TLS certificate에서 From ACM을 선택하고 아까 발급받은 인증서를 선택한다.
8. 언급되지 않은 옵션들은 전부 default 값들로 설정하고 “create load balancer” 클릭.

### ALB(Application Load Balancer)

- 어플리케이션에 사용되는 여러 대의 서버들의 트래픽을 분산시켜주는(scale-out) 역할을 한다. ALB를 설정하면 사용자의 모든 요청을 우선적으로 ALB가 받게 하고, ALB는 어떤 요청인지 구분하여 각 요청을 처리할 수 있는 서버에게 해당 요청을 전달한다.
- 단순히 nginx나 apache 같이 웹서버로써 활용할 수도 있다.
- AWS에 한해서, ALB를 사용하면 SSL을 무료로 제공받아 사용 가능하다. (도메인은 별도)

## 리다이렉트 설정

### HTTP:80 규칙 추가

[http://www.example.com](http://www.example.com) 이나 [http://adfsaf.example.com](http://adfsaf.example.com) 처럼 http로 접근을 시도하거나, 루트 도메인이 www가 아닌 경우, 반드시 [https://www.example.com](https://www.example.com) 으로 리다이렉트하도록 설정한다.

1. 방금 만든 로드 밸런서의 세부 사항을 본다.
2. `Listener and Rules` 항목에서 HTTP:80 의 rules 항목 링크를 클릭한다.
3. 위 조건에 해당하도록 조건을 추가한다.
    1. Condition: Host Header가 [www.example.com](http://www.example.com) 또는 *.example.com 인 경우
    2. Action: HTTPS:443으로 리다이렉트한다.
    3. Priority: 1순위

### HTTPS:443 규칙 추가(선택)

위처럼 필요에 따라 규칙을 추가할 수 있다.

## EC2 보안 그룹

1. 현재 사용 중인 인스턴스 서버에서 `보안 그룹`을 클릭한다.
2. “보안 그룹 생성” 클릭.
3. 아까 만든 로드 벨런서의 보안 그룹을 was와 web 서버에 적용.

## 테스트

로드 벨런서 세부 항목에 들어가보면, 로드 벨런서의 DNS 이름을 볼 수 있다. 해당 이름을 복사하고 URL에 넣어서 검색해보자. http로 접근하면 web 서버를, https로 접근하면 was 서버를 볼 수 있다. 

- web 접근 시 “404”가 뜬다고? 그건 백 서버에서 “/” uri에 대한 get 요청 처리를 안 해서 그렇다. (정상이다.)
- “mixed content” 에러가 뜬다고? 그건 was 서버 쪽에서 손을 좀 봐야 한다. (was에서 http 방식이 아닌 https 방식으로 web 서버에 전송해야 함.)

### Health check 문제

로드 벨런서로 직접 접속했을 때 404 에러를 보았다면, 위와 동일한 설정을 했다는 가정 하에 web-target 타겟 그룹에서도 “unhealthy” 문제가 뜰 것이다. 이게 백엔드 서버에서는 “/” 루트 uri에 대한 대응이 아무것도 없으면 404가 뜨는데, 그래서 발생하는 문제이다.

이 상태를 방치하면 ALB에서는 자동으로 해당 서버에 장애가 있다고 판단하고, 해당 서버에 대한 트래픽을 원천 차단하는 문제가 발생한다.

1. 이 문제를 해결하려면 “healthy check settings”에 들어가서 edit을 누른다.
2. 그리고 success codes를 200 → 404로 바꾼다. 404가 뜨는 것이 정상이라는 것을 알려주는 것이다.

시간이 좀 지나면 “healthy”로 전환될 것이다.

## ALB 레코드 생성 (ALB에 외부 도메인 연동)

우리의 최종 목표는 로드 벨런서의 DNS 이름으로 직접 접속하는 것이 아닌, 우리가 외부에서 발급받았던 가상의 DNS 레코드로 접속하도록 하는 것! 

1. “route 53”에서 지금 쓰고 있는 도메인 세부 설정으로 들어간다. 
2. `레코드 생성` 클릭.
3. 우측 상단에 `빠른 생성` 으로 전환한 뒤, “별칭”을 활성화한 후 “트래픽 라우팅 대상”을 “Application/Classic Load Balancer에 대한 별칭”을 선택. 그리고 지역은 현재 사용 중인 인스턴스 서버의 가용 영역에 해당하는 지역을 선택한다. 
    1. 유형은 A유형을 선택한다. 
    2. 서브 도메인이 있으면 별도로 추가해줘야 한다.
    3. TTL은 설정이 불가능하다. AWS 기본 설정을 따라간다고 한다.
4. “레코드 생성” 클릭.

이제 사용자는 ALB의 진짜 DNS 이름이 아닌, 가상의 DNS 레코드 이름을 통해 was 서버에 접근할 수 있을 것이다.

참고: 저번에 만든 CNAME 레코드는 외부 DNS 업체에게 인증받기 위한 용도로 썼을 뿐이지, ALB 서버의 DNS 레코드 이름이 아니다. (접속해보면 접속할 수 없는 링크라고 뜸.)

## ERR_CONNECTION_TIMED_OUT

하지만 이 상태로 DNS 레코드 이름으로 접속해보려고 하면 위 에러가 뜰 것이다.

linux 등에서 아래 명령어를 입력하여 DNS 레코드가 올바르게 설정되어 있는지 확인한다. (Postman을 사용해서 직접 DNS 레코드에 접속해서 에러 로그를 확인해도 좋다.)

```
dig +short www.example.com
```

**여기서 본인의 인스턴스 서버의 ip주소가 출력되면 안된다.** 응? 무슨 소리냐고?

지금 EC2 인스턴스 서버가 받을 요청은 전부 ALB가 대신 받고 있다. 지금 당장 자신의 EC2 ip 주소를 입력해서 접속을 시도해보라. 똑같이 타임아웃 에러가 발생할 것이다. **AWS에서 자체적으로 EC2 서버를 private하게 숨겨놓고 ALB를 앞장세워 놓은 구조를 만들어두었기 때문이다.** (그래서 이제 EC2에 적용하던 탄력적 ip 주소는 버려도 된다.)

### 해결책: DNS 레코드에서 ALB public ip 주소를 반환하도록 한다.

이 작업을 위해서 아래 작업을 순차적으로 따른다.

1. “route 53”에 `레코드 테스트` 기능이 있다. 이거로 A 타입의 레코드 유형(앞서 ALB DNS 이름을 A타입으로 레코드 생성을 했으니까)에 대해 “응답 수신”을 눌러본다.
2. route 53에서 반환된 응답의 ip 주소를 확인한다. 이게 ALB 서버의 “퍼블릭 ip 주소”이다.
3. 앞서 도메인을 발급받았던 [내 도메인 한국](https://xn--220b31d95hq8o.xn--3e0b707e/page/domain_conf_view.php?id=1517724&order=1&page=1) 사이트의 “도메인 관리” 항목에 들어간다.
4. 고급 설정의 IP연결(A)의 값에는 기존의 EC2 퍼블릭 ip 주소가 입력되어 있을 것이다. (이것 때문에 자꾸 에러가 생기는 것이었던 것.) 이 값을 ALB 서버의 ip 주소로 수정해준다.

이제 DNS 레코드를 통해 접속해보면 정상적으로 접속이 된다!

[참고 링크](https://jforj.tistory.com/278)

[참고 링크 2](https://programforlife.tistory.com/112)

[참고 링크 3](https://velog.io/@server30sopt/EC2-HTTPS%EB%A1%9C-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0)

## 번외) mixed content 에러

프론트 서버와 백 서버에서는 https 관련 설정을 다룬 적이 없다. 그래서 처음으로 https를 적용하면 이 에러가 뜰 수밖에 없다.

- 프론트에서는 http 요청이 아닌 https 요청을 하도록 수정해야 함.
- 백에서는 필요에 따라 SSL 인증서를 발급받아 https 통신을 가능케 해야 함. 하지만 지금 나는 EC2에 프론트와 백 서버를 같이 돌리고 있기 때문에 http 통신이면 충분할 것으로 봄.